##  meta 中 viewport 作用 | 网页宽带设置设备宽度
> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> html 文件中有这么一行, 作用是什么?

HTML文件中的这一行是一个`<meta>`标签，用于设置视口（viewport）的相关属性。这在创建响应式网站时是非常重要的。

`<meta name="viewport" content="width=device-width, initial-scale=1.0" />` 这一行的作用是告诉浏览器将视口的宽度设置为设备的宽度，并且设置视口的初始缩放级别为1.0。这主要在移动设备上有影响。

-   `width=device-width`: 这个设置使得网页宽度等于设备的屏幕宽度，而不是使用默认的980px或者1024px。这样可以保证页面内容在任何设备上都可以完全适应屏幕宽度。
    
-   `initial-scale=1.0`: 这个设置控制页面首次被加载时的缩放级别。设置为1.0意味着网页将以1:1的比例展示，没有任何缩放。
    

这些设置在创建响应式网站时非常重要，因为它们确保了网页在移动设备上可以正确地呈现，无论设备的屏幕大小如何。

## 微元素
### css中的::before 跟 ::after

在 CSS 中，`::before` 和 `::after` 是两个伪元素，它们用于在元素的内容前或内容后插入内容。这些内容默认被插入为行内元素。

-   `::before` 伪元素在元素内容的前面插入内容。例如，你可以使用它来插入开头引号，或者在列表项前面插入特殊符号。
    
-   `::after` 伪元素在元素内容的后面插入内容。例如，你可以使用它来插入结尾引号，或者在链接后面插入表示链接类型的图标。
    

这两个伪元素通常配合 `content` 属性一起使用，`content` 属性用于指定要插入的内容。这个内容可以是文本、图片，或者是 `attr()` 函数用于获取元素的某个属性值。

下面是一个使用 `::before` 和 `::after` 的例子：

```
html<style>
    p::before {
        content: "[";
    }

    p::after {
        content: "]";
    }
</style>
<p>Hello, world!</p>

```

这段代码会在段落的内容前后分别添加一个 "\[" 和 "\]"，因此页面上显示的结果会是："\[Hello, world!\]"

需要注意的是，如果 `content` 属性为空或未设置（例如 `content: ""`），`::before` 和 `::after` 伪元素仍然会被创建，但它们不会有可见的内容。然而，你仍然可以给它们设置宽度、高度、背景颜色等属性，这是创建一些特殊布局或图形（例如清除浮动、制作纯 CSS 图形等）的常见技术。



伪元素是CSS中的一种特殊类型的选择器，它允许你样式化页面上特定部分的内容。这些部分并不是文档的实际内容，而是你可以通过CSS创建和样式化的内容。换句话说，伪元素让你能够操作并为页面上原本不存在的元素添加样式。

比如，`::before` 和 `::after` 伪元素允许你在元素的内容前或者后插入内容。这个内容被插入到页面的DOM中，但在HTML源码中并不可见。例如：

```
html<style>
    p::before {
        content: "注意: ";
    }
</style>
<p>这是一条重要的信息。</p>

```

在这个例子中，浏览器将在段落的文本前面插入"注意: "。然而，在HTML源码中，并没有"注意: "这个文本，它是通过CSS创建并插入到页面中的。

还有一些其他的伪元素，比如 `::first-line` 和 `::first-letter`，它们分别允许你样式化一个块级元素的第一行或第一个字母。

请注意，伪元素在CSS语法中需要使用两个冒号 (`::`) 来开始，这是为了将它们与伪类（如 `:hover`、`:active` 等）区分开，伪类只使用一个冒号。然而，为了兼容旧版本的CSS，许多浏览器仍然接受使用一个冒号的伪元素语法（例如 `:before` 和 `:after`）。


伪元素不算文档的一部分, 那么如果div中有一个span子元素, ::before算第一个元素, 还是span呢?

虽然 `::before` 和 `::after` 伪元素在视觉上表现得像是 DOM 中的元素，但实际上它们并不是文档的一部分，也不会在 DOM 树中出现。因此，对于文档结构和 JavaScript 操作来说，它们是不存在的。

在你的例子中，如果一个 `div` 元素中有一个 `span` 子元素，并且 `div` 设置了 `::before` 伪元素，那么在 CSS 渲染层面上，`::before` 会作为 `div` 的第一个子元素被渲染，看起来好像 `::before` 是第一个元素。

然而，从 DOM 结构的角度来看，`span` 是 `div` 的第一个子元素，因为 `::before` 并不是真正的 DOM 元素。因此，如果你使用 JavaScript 来查询 `div` 的第一个子元素，你会得到 `span`，而不是 `::before`。

![User](https://chat.openai.com/_next/image?url=https%3A%2F%2Fs.gravatar.com%2Favatar%2F7eb333bea6bc385028c83a781774d076%3Fs%3D480%26r%3Dpg%26d%3Dhttps%253A%252F%252Fcdn.auth0.com%252Favatars%252Fho.png&w=96&q=75)

## float 浮动 | 原为图片环绕文字

介绍一下 float: left; 什么时候生效, 以及作用是什么?

在 CSS 中，`float` 属性被用于指定一个元素应该如何浮动。元素可以浮动在其父容器的左侧（`float: left;`）或右侧（`float: right;`）。当元素被设置为浮动后，它会被移出正常的文档流，并向左或向右移动，直到它的外边缘碰到包含块或另一个浮动元素的边框为止。其他的文本和内联元素则会环绕在浮动元素的周围。

浮动最初是为了实现文字环绕图像的效果，但后来也被广泛用于创建布局和列。例如，如果你有两个并排的块级元素，你可以将一个元素设置为 `float: left;`，另一个元素设置为 `float: right;`，这样就能让它们在一行上显示。

下面是一个简单的例子：

```
html<style>
    img {
        float: left;
        margin-right: 10px;
    }
</style>

<img src="example.jpg" alt="示例图片" />
<p>这里是一段文字，它将环绕在浮动的图片周围，形成一个文字环绕图像的效果。</p>

```

在这个例子中，图片被设置为左浮动，这意味着它会尽可能地向左移动。段落文本将环绕在图片的右侧和下方。

然而，请注意 `float` 有一些陷阱，比如它会使得父元素失去高度（因为浮动元素被移出了正常的文档流）。这个问题通常可以通过添加一个清除浮动（clearfix）的元素来解决。而在现代网页布局中，`float` 的使用已经被 Flexbox 和 Grid 布局逐渐取代，它们提供了更强大且易用的布局工具。

### float 与行内块

设置成 float: left; 的元素会变成行内块吗?

当你把一个元素设置为 `float: left;` 或 `float: right;` 时，这个元素的行为确实会在一些方面类似于 `display: inline-block;`。但并不是说浮动元素会被实际转换成 `display: inline-block;`。实际上，`float` 和 `display` 是两个独立的CSS属性，它们可以同时存在在一个元素上，并且互相不影响。

以下是几个方面的比较：

1.  类似于行内块元素，浮动元素可以并排放置，而不会像块级元素那样占据整行。
    
2.  但是，浮动元素并不遵循正常的行内元素流，而是被移出了正常文档流，并向左或向右移动，直到它的外边缘碰到包含块或另一个浮动元素的边框为止。这一点是和行内块元素不同的。
    
3.  对于浮动元素，其宽度默认是内容的宽度，这点和行内块元素是相似的。但如果没有明确指定宽度，浮动元素会尽可能地收缩以适应内容的宽度。
    
4.  对于浮动元素，可以应用垂直和水平的外边距和内边距，就像行内块元素一样。
    
5.  当元素被设置为浮动后，它的子元素和兄弟元素会环绕它，这是行内块元素所没有的特性。
    

所以，尽管浮动元素在某些方面的行为类似于行内块元素，但它们还是有许多不同的地方。

### float 不需条件, 但是float会从流中移除, 要父元素计算其高度需要清除浮动

要设置元素float 生效, 需要设置css的其他属性或者父元素需要设置什么css属性吗?

对于一个元素来说，要设置 `float` 生效，其本身不需要设置其他 CSS 属性，直接设置 `float: left;` 或者 `float: right;` 即可。然而，使用浮动属性后可能会遇到一些布局问题，例如父元素高度塌陷等，需要通过设置其他 CSS 属性来解决。

以下是几个可能需要注意的地方：

1.  **清除浮动（Clearing Floats）**：当一个元素内部的子元素被设置为浮动后，这个元素可能会失去其应有的高度，因为浮动元素会被移出正常的文档流。为了解决这个问题，通常需要在浮动元素的父元素内部添加一个清除浮动的元素。这个元素可以通过 `clear: both;` 属性来清除之前的浮动效果，从而使得父元素可以获取到正确的高度。这种方法被称为 clearfix 技巧。
    
2.  **包含块（Containing Block）**：浮动元素的位置是相对于其最近的包含块（包含这个元素的最近的块级祖先元素）计算的。如果父元素没有明确的宽度，那么浮动元素可能会以一种意想不到的方式移动。
    
3.  **浮动元素的宽度**：如果没有指定宽度，浮动元素的宽度将是其内容的宽度。如果你希望浮动元素有一个确定的宽度，你可以设置 `width` 属性。
    
4.  **边距重叠（Margin Collapsing）**：请注意，当元素被设置为浮动后，它就不再参与垂直边距的合并。这意味着如果你有两个相邻的浮动元素，它们的垂直边距不会像块级元素那样合并。
    

以上只是一些常见的注意点。实际使用时可能还会遇到其他问题，需要具体问题具体分析。



上面这个例子 <style> img { float: left; margin-right: 10px; } </style> <div> <img src="example.jpg" alt="示例图片" /> <p>这里是一段文字，它将环绕在浮动的图片周围，形成一个文字环绕图像的效果。</p> </div> 如果我加上一个div父元素, 那么这个div元素的高度如何计算呢?

在这个例子中，`div` 是 `img` 和 `p` 元素的父元素。如果 `img` 被设置为浮动（`float: left;`），它会被移出正常的文档流，这就意味着 `img` 的高度将不再影响其父元素 `div` 的高度计算。换句话说，如果没有其他的设置，`div` 的高度只会考虑 `p` 元素的高度。

这就可能导致一个问题，即父元素 `div` 的高度塌陷。虽然浮动的 `img` 在视觉上是在 `div` 内部，但由于 `img` 被浮动了，它的高度在计算 `div` 的高度时不会被考虑。

为了解决这个问题，我们常常使用一种叫做 "clearfix" 的技巧。"clearfix" 可以使得父元素 `div` "清除" 浮动元素的影响，使得 `div` 的高度可以正常计算。

以下是使用 "clearfix" 的方式：

```
html<style>
    img {
        float: left;
        margin-right: 10px;
    }

    .clearfix::after {
        content: "";
        display: table;
        clear: both;
    }
</style>

<div class="clearfix">
    <img src="example.jpg" alt="示例图片" />
    <p>这里是一段文字，它将环绕在浮动的图片周围，形成一个文字环绕图像的效果。</p>
</div>

```

在这个例子中，我们给 `div` 添加了一个 `clearfix` 类，并设置了伪元素 `::after` 的 `clear: both;` 属性。这样，`div` 就可以正确地计算其高度了，即使其中有浮动元素。



### position: absolute; 生效需要什么条件

CSS 中的 `position: absolute;` 属性可以让元素脱离正常的文档流，并相对于最近的定位祖先元素（即设定了 `position` 属性为 `relative`, `absolute`, `fixed` 或 `sticky` 的元素）进行定位。如果没有定位祖先元素，那么元素会相对于初始包含块（通常是根元素，或者是整个文档窗口）进行定位。

以下是 `position: absolute;` 属性生效的条件：

1.  当元素的 `position` 属性被设置为 `absolute` 时，这个元素就被视为绝对定位元素。
    
2.  绝对定位元素的位置是相对于其最近的定位祖先元素计算的。如果没有定位祖先元素，那么元素会相对于初始包含块进行定位。
    
3.  一旦元素被设置为绝对定位，它就会脱离正常的文档流。这意味着它的位置不会影响到其兄弟元素的位置，也不会受到兄弟元素的影响。
    
4.  绝对定位元素的偏移（即 `top`, `right`, `bottom`, `left` 的值）是相对于其最近的定位祖先元素的内边距边缘计算的。
    

例如：

```
html<div style="position: relative; width: 200px; height: 200px;">
    <div style="position: absolute; top: 10px; left: 20px;">我是绝对定位的元素</div>
</div>

```

在这个例子中，内部的 `div` 元素是绝对定位的，它的位置是相对于最近的定位祖先元素（即外部的 `div` 元素）计算的，具体为距离顶部 10px，左侧 20px 的位置。